{"version":3,"file":"../app/api/darts/route.js","mappings":"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","sources":["webpack://unreal/external commonjs \"next/dist/server/app-render/after-task-async-storage.external.js\"","webpack://unreal/external commonjs2 \"module\"","webpack://unreal/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://unreal/./src/utils/web2.ts","webpack://unreal/./src/utils/web3.ts","webpack://unreal/./src/utils/index.ts","webpack://unreal/external commonjs2 \"punycode\"","webpack://unreal/src/app/api/darts/route.ts","webpack://unreal/sentry-wrapper-module","webpack://unreal/?1727","webpack://unreal/./supabase/server.ts","webpack://unreal/external commonjs2 \"process\"","webpack://unreal/external commonjs2 \"os\"","webpack://unreal/external commonjs2 \"stream\"","webpack://unreal/../../../src/server/app-render/encryption-utils.ts","webpack://unreal/external commonjs2 \"util\"","webpack://unreal/external commonjs2 \"fs\"","webpack://unreal/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://unreal/external node-commonjs \"node:child_process\"","webpack://unreal/external commonjs2 \"path\"","webpack://unreal/external commonjs2 \"diagnostics_channel\"","webpack://unreal/external node-commonjs \"node:http\"","webpack://unreal/external node-commonjs \"node:zlib\"","webpack://unreal/external node-commonjs \"node:tls\"","webpack://unreal/external node-commonjs \"node:https\"","webpack://unreal/external commonjs \"next/dist/compiled/next-server/app-route.runtime.prod.js\"","webpack://unreal/./node_modules/.pnpm/next@15.2.4_@babel+core@7.26.10_@opentelemetry+api@1.9.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/app-render/encryption.js","webpack://unreal/external node-commonjs \"node:os\"","webpack://unreal/external node-commonjs \"node:diagnostics_channel\"","webpack://unreal/./src/utils/sentryUtils.ts","webpack://unreal/external commonjs2 \"crypto\"","webpack://unreal/external commonjs2 \"https\"","webpack://unreal/external commonjs2 \"tls\"","webpack://unreal/external node-commonjs \"node:stream\"","webpack://unreal/external node-commonjs \"node:util\"","webpack://unreal/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://unreal/../../../../src/build/webpack/loaders/next-flight-loader/action-validate.ts","webpack://unreal/external node-commonjs \"node:fs\"","webpack://unreal/external commonjs2 \"worker_threads\"","webpack://unreal/external commonjs2 \"zlib\"","webpack://unreal/external commonjs2 \"perf_hooks\"","webpack://unreal/external node-commonjs \"node:worker_threads\"","webpack://unreal/external node-commonjs \"node:path\"","webpack://unreal/external node-commonjs \"node:net\"","webpack://unreal/external node-commonjs \"node:crypto\"","webpack://unreal/external commonjs2 \"buffer\"","webpack://unreal/external commonjs2 \"url\"","webpack://unreal/external commonjs2 \"child_process\"","webpack://unreal/external node-commonjs \"node:readline\"","webpack://unreal/external commonjs2 \"http\"","webpack://unreal/./node_modules/.pnpm/next@15.2.4_@babel+core@7.26.10_@opentelemetry+api@1.9.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js","webpack://unreal/external commonjs2 \"tty\"","webpack://unreal/./src/queries/user.ts","webpack://unreal/external commonjs2 \"async_hooks\"","webpack://unreal/?34b8","webpack://unreal/external node-commonjs \"node:inspector\"","webpack://unreal/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://unreal/./node_modules/.pnpm/require-in-the-middle@7.5.2/node_modules/require-in-the-middle/ sync","webpack://unreal/external commonjs2 \"net\"","webpack://unreal/external commonjs2 \"events\""],"sourcesContent":["module.exports = require(\"next/dist/server/app-render/after-task-async-storage.external.js\");","module.exports = require(\"module\");","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","import { ethers } from \"ethers\";\n\n// Function to generate Ethereum wallet\nexport const generateEthereumWallet = (): WalletObject => {\n  // Generate Ethereum Wallet using ethers.js\n  const wallet = ethers.Wallet.createRandom();\n\n  return {\n    address: wallet.address,\n    privateKey: wallet.privateKey,\n    publicKey: wallet.publicKey,\n  };\n};\n\n// returns a range of numbers to be used for pagination.\nexport function getRange(page: number, limit: number) {\n  const from = page * limit;\n  const to = from + limit - 1;\n\n  return [from, to];\n}\n\nexport function isValidFileName(name: string): boolean {\n  // Basic validation: empty strings are not allowed\n  if (!name) return false;\n\n  // Check if it's just a dot (hidden files/folders)\n  if (name === \".\") return false;\n\n  // Check if it starts with a dot (hidden files/folders)\n  if (name.startsWith(\".\")) {\n    // Hidden files/folders are allowed, but we should check if they're valid after the dot\n    const rest = name.slice(1);\n    return rest.length > 0 && isValidFileName(rest);\n  }\n\n  // // Check if it contains invalid characters\n  // const invalidChars = /[\\/*?:<>|\\\\]/;\n  // if (invalidChars.test(name)) return false;\n\n  // Check if it exceeds maximum length\n  const maxNameLength = 255; // Windows limit\n  if (name.length > maxNameLength) return false;\n\n  // If we pass all checks, it's a valid file/folder name\n  return true;\n}\n\nexport function isHighQualityImage(filename: string): boolean {\n  if (!isValidFileName(filename)) {\n    return false;\n  }\n  // const lowQExt = [\"webp\", \"svg\", \"ico\"];\n  const highQExt = [\"jpeg\", \"jpg\", \"png\"];\n\n  return highQExt.includes(filename.toLowerCase().split(\".\").pop() || \"\");\n}\n\nexport function truncateText(\n  text: string | undefined | null,\n  wordLimit: number = 10,\n): string {\n  if (!text) return \"\";\n  const words = text.split(\" \");\n  return words.length > wordLimit\n    ? words.slice(0, wordLimit).join(\" \") + \"...\"\n    : text;\n}\n\nexport const getNotificationMessage = (\n  type: string,\n  senderName: string | null | undefined,\n) => {\n  switch (type) {\n    case \"like\":\n      return `${senderName} liked your post!`;\n    case \"comment\":\n      return `${senderName} commented on your post!`;\n    case \"share\":\n      return `${senderName} just shared your post! Your content is reaching more people.`;\n    case \"follow\":\n      return `${senderName} followed you!`;\n    default:\n      return \"You have a new notification!\";\n  }\n};\n\nexport function formatDate(dateString: string) {\n  const date = new Date(dateString);\n\n  return date.toLocaleDateString(\"en-GB\", {\n    day: \"numeric\",\n    month: \"short\",\n    year: \"numeric\",\n  });\n}\n\nexport function getImageResolution(imageUrl: string) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.src = imageUrl;\n    img.onload = () => {\n      resolve(`${img.width} Ã— ${img.height} `);\n    };\n    img.onerror = (err) => reject(err);\n  });\n}\n\n// export function downloadImage(imageUrl: string, fileName?: string) {\n//   const uniqueId = Date.now(); // Unique timestamp\n//   const defaultFileName = `downloaded-image-${uniqueId}.jpg`; //  unique filename\n\n//   fetch(imageUrl)\n//     .then((response) => response.blob())\n//     .then((blob) => {\n//       const url = window.URL.createObjectURL(blob);\n//       const a = document.createElement(\"a\");\n//       a.href = url;\n//       a.download = fileName || defaultFileName;\n//       document.body.appendChild(a);\n//       a.click();\n//       document.body.removeChild(a);\n//       window.URL.revokeObjectURL(url);\n//     })\n//     .catch((error) => console.error(\"Error downloading image:\", error));\n// }\n\nexport function downloadImage(imageUrl: string, fileName?: string) {\n  fetch(imageUrl)\n    .then((response) => response.blob())\n    .then((blob) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const a = document.createElement(\"a\");\n        a.href = reader.result as string;\n        a.download = fileName || `downloaded-image-${Date.now()}.jpg`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n      };\n      reader.readAsDataURL(blob);\n    })\n    .catch((error) => console.error(\"Error downloading image:\", error));\n}\n\nexport const formatMoney = (value: number) => {\n  return new Intl.NumberFormat(\"en-US\").format(value);\n};\n\nexport function formatNumber(num: number): string {\n  if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(1).replace(/\\.0$/, '') + 'B';\n  if (num >= 1_000_000) return (num / 1_000_000).toFixed(1).replace(/\\.0$/, '') + 'M';\n  if (num >= 1_000) return (num / 1_000).toFixed(1).replace(/\\.0$/, '') + 'k';\n  return num.toString();\n}\n\nexport function splitName(fullName: string) {\n  let parts = fullName.trim().split(\" \");\n  let firstName = parts[0];\n  let lastName = parts.slice(1).join(\" \"); // Handles cases with middle names\n  return { firstName, lastName };\n}\n","import { Chain, createThirdwebClient, getContract } from \"thirdweb\";\n\nexport const client = createThirdwebClient({\n  clientId: process.env.NEXT_PUBLIC_TW_CLIENT_ID as string,\n});\n\nexport const getContractInstance = (chain: Chain, address: string) => {\n  return getContract({\n    client,\n    chain,\n    address,\n  });\n};\n","export * from \"./web2\";\nexport * from \"./web3\";\nexport * from \"./sentryUtils\";\n","module.exports = require(\"punycode\");","import { NextRequest, NextResponse } from \"next/server\";\n// import { axiosInstance } from \"@/lib/axiosInstance\";\n// import axios from \"axios\";\nimport { getUser } from \"@/queries/user\";\nimport { createClient, SupabaseClient } from \"@supabase/supabase-js\";\n// import { withEdgeHighlight } from \"@/utils/edge-highlight.config\";\n\n// export const runtime = \"edge\"; // Use Edge Functions\n// export const maxDuration = 300; // 5-minute max execution time\n\nexport async function POST(req: NextRequest) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string;\n  const private_SRK = process.env.SUPABASE_SERVICE_ROLE_KEY as string;\n\n  const secretSupabaseClient: SupabaseClient = createClient(\n    supabaseUrl,\n    private_SRK,\n  );\n\n  try {\n    // Parse request body\n    const requestData = await req.json();\n    // console.log(\"url\", process.env.NEXT_PUBLIC_API_URL);\n    //get user\n    const user = await getUser();\n\n    if (!user || !user.creditBalance || !user.wallet?.privateKey) return;\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    // Add Authorization only when `creditBalance <= 0`\n    if (user.creditBalance <= 0) {\n      headers.Authorization = `Bearer ${user.wallet.privateKey}`;\n    }\n\n    //send to queue.\n    const { error } = await secretSupabaseClient.rpc(\"send_to_queue\", {\n      queue_name: \"dart_jobs\",\n      msg: requestData,\n      // delay: 0, // No delay\n    });\n\n    // if (error) throw new Error(`Request failed with status: ${error}`);\n    // const response = await fetch(\n    //   `${process.env.NEXT_PUBLIC_API_URL}/api/  darts`,\n    //   {\n    //     method: \"POST\",\n    //     headers,\n    //     body: JSON.stringify(requestData),\n    //   },\n    // );\n\n    if (error) {\n      throw new Error(`Request failed with status: ${error}`);\n    }\n    // if (!response.ok) {\n    //   throw new Error(`Request failed with status: ${response.status}`);\n    // }\n\n    // const responseData = await response.json();\n    return NextResponse.json({ status: true });\n  } catch (error: unknown) {\n    console.error(\"Error forwarding request to /darts:\", error);\n\n    // if (axios.isAxiosError(error)) {\n    //   return NextResponse.json(\n    //     { error: error.response?.data || error.message },\n    //     { status: error.response?.status || 500 },\n    //   );\n    // }\n\n    return NextResponse.json(\n      { error: \"Internal Server Error\" },\n      { status: 500 },\n    );\n  }\n}\n","import * as Sentry from '@sentry/nextjs';\nimport * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport {} from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nfunction wrapHandler(handler, method) {\n  // Running the instrumentation code during the build phase will mark any function as \"dynamic\" because we're accessing\n  // the Request object. We do not want to turn handlers dynamic so we skip instrumentation in the build phase.\n  if (process.env.NEXT_PHASE === 'phase-production-build') {\n    return handler;\n  }\n\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return new Proxy(handler, {\n    apply: (originalFunction, thisArg, args) => {\n      let headers = undefined;\n\n      // We try-catch here just in case the API around `requestAsyncStorage` changes unexpectedly since it is not public API\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        headers = requestAsyncStore?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return Sentry.wrapRouteHandlerWithSentry(originalFunction , {\n        method,\n        parameterizedRoute: '/api/darts',\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst GET = wrapHandler(serverComponentModule.GET , 'GET');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst POST = wrapHandler(serverComponentModule.POST , 'POST');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PUT = wrapHandler(serverComponentModule.PUT , 'PUT');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst PATCH = wrapHandler(serverComponentModule.PATCH , 'PATCH');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst DELETE = wrapHandler(serverComponentModule.DELETE , 'DELETE');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst HEAD = wrapHandler(serverComponentModule.HEAD , 'HEAD');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst OPTIONS = wrapHandler(serverComponentModule.OPTIONS , 'OPTIONS');\n\nexport { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT };\n","import { AppRouteRouteModule } from \"next/dist/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"/Users/a0000/projects/unreal/src/app/api/darts/route.ts\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/darts/route\",\n        pathname: \"/api/darts\",\n        filename: \"route\",\n        bundlePath: \"app/api/darts/route\"\n    },\n    resolvedPagePath: \"/Users/a0000/projects/unreal/src/app/api/darts/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","import { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"$/types/database.types\";\n\nexport async function createClient(): Promise<SupabaseClient<Database>> {\n  const cookieStore = await cookies();\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options),\n            );\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n      auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true,\n      },\n    },\n  );\n}\n","module.exports = require(\"process\");","module.exports = require(\"os\");","module.exports = require(\"stream\");","import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");","module.exports = require(\"path\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","module.exports = require(\"next/dist/compiled/next-server/app-route.runtime.prod.js\");","/* eslint-disable import/no-extraneous-dependencies */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    decryptActionBoundArgs: null,\n    encryptActionBoundArgs: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    decryptActionBoundArgs: function() {\n        return decryptActionBoundArgs;\n    },\n    encryptActionBoundArgs: function() {\n        return encryptActionBoundArgs;\n    }\n});\nrequire(\"server-only\");\nconst _serveredge = require(\"react-server-dom-webpack/server.edge\");\nconst _clientedge = require(\"react-server-dom-webpack/client.edge\");\nconst _nodewebstreamshelper = require(\"../stream-utils/node-web-streams-helper\");\nconst _encryptionutils = require(\"./encryption-utils\");\nconst _workunitasyncstorageexternal = require(\"./work-unit-async-storage.external\");\nconst _dynamicrendering = require(\"./dynamic-rendering\");\nconst _react = /*#__PURE__*/ _interop_require_default(require(\"react\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n/**\n * Decrypt the serialized string with the action id as the salt.\n */ async function decodeActionBoundArg(actionId, arg) {\n    const key = await (0, _encryptionutils.getActionEncryptionKey)();\n    if (typeof key === 'undefined') {\n        throw Object.defineProperty(new Error(`Missing encryption key for Server Action. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E65\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Get the iv (16 bytes) and the payload from the arg.\n    const originalPayload = atob(arg);\n    const ivValue = originalPayload.slice(0, 16);\n    const payload = originalPayload.slice(16);\n    const decrypted = textDecoder.decode(await (0, _encryptionutils.decrypt)(key, (0, _encryptionutils.stringToUint8Array)(ivValue), (0, _encryptionutils.stringToUint8Array)(payload)));\n    if (!decrypted.startsWith(actionId)) {\n        throw Object.defineProperty(new Error('Invalid Server Action payload: failed to decrypt.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E191\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return decrypted.slice(actionId.length);\n}\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */ async function encodeActionBoundArg(actionId, arg) {\n    const key = await (0, _encryptionutils.getActionEncryptionKey)();\n    if (key === undefined) {\n        throw Object.defineProperty(new Error(`Missing encryption key for Server Action. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E65\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Get 16 random bytes as iv.\n    const randomBytes = new Uint8Array(16);\n    _workunitasyncstorageexternal.workUnitAsyncStorage.exit(()=>crypto.getRandomValues(randomBytes));\n    const ivValue = (0, _encryptionutils.arrayBufferToString)(randomBytes.buffer);\n    const encrypted = await (0, _encryptionutils.encrypt)(key, randomBytes, textEncoder.encode(actionId + arg));\n    return btoa(ivValue + (0, _encryptionutils.arrayBufferToString)(encrypted));\n}\nconst encryptActionBoundArgs = _react.default.cache(async function encryptActionBoundArgs(actionId, ...args) {\n    const { clientModules } = (0, _encryptionutils.getClientReferenceManifestForRsc)();\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error();\n    Error.captureStackTrace(error, encryptActionBoundArgs);\n    let didCatchError = false;\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    const hangingInputAbortSignal = (workUnitStore == null ? void 0 : workUnitStore.type) === 'prerender' ? (0, _dynamicrendering.createHangingInputAbortSignal)(workUnitStore) : undefined;\n    // Using Flight to serialize the args into a string.\n    const serialized = await (0, _nodewebstreamshelper.streamToString)((0, _serveredge.renderToReadableStream)(args, clientModules, {\n        signal: hangingInputAbortSignal,\n        onError (err) {\n            if (hangingInputAbortSignal == null ? void 0 : hangingInputAbortSignal.aborted) {\n                return;\n            }\n            // We're only reporting one error at a time, starting with the first.\n            if (didCatchError) {\n                return;\n            }\n            didCatchError = true;\n            // Use the original error message together with the previously created\n            // stack, because err.stack is a useless Flight Server call stack.\n            error.message = err instanceof Error ? err.message : String(err);\n        }\n    }), // We pass the abort signal to `streamToString` so that no chunks are\n    // included that are emitted after the signal was already aborted. This\n    // ensures that we can encode hanging promises.\n    hangingInputAbortSignal);\n    if (didCatchError) {\n        if (process.env.NODE_ENV === 'development') {\n            // Logging the error is needed for server functions that are passed to the\n            // client where the decryption is not done during rendering. Console\n            // replaying allows us to still show the error dev overlay in this case.\n            console.error(error);\n        }\n        throw error;\n    }\n    if (!workUnitStore) {\n        return encodeActionBoundArg(actionId, serialized);\n    }\n    const prerenderResumeDataCache = (0, _workunitasyncstorageexternal.getPrerenderResumeDataCache)(workUnitStore);\n    const renderResumeDataCache = (0, _workunitasyncstorageexternal.getRenderResumeDataCache)(workUnitStore);\n    const cacheKey = actionId + serialized;\n    const cachedEncrypted = (prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.encryptedBoundArgs.get(cacheKey)) ?? (renderResumeDataCache == null ? void 0 : renderResumeDataCache.encryptedBoundArgs.get(cacheKey));\n    if (cachedEncrypted) {\n        return cachedEncrypted;\n    }\n    const cacheSignal = workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined;\n    cacheSignal == null ? void 0 : cacheSignal.beginRead();\n    const encrypted = await encodeActionBoundArg(actionId, serialized);\n    cacheSignal == null ? void 0 : cacheSignal.endRead();\n    prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.encryptedBoundArgs.set(cacheKey, encrypted);\n    return encrypted;\n});\nasync function decryptActionBoundArgs(actionId, encryptedPromise) {\n    const encrypted = await encryptedPromise;\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    let decrypted;\n    if (workUnitStore) {\n        const cacheSignal = workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined;\n        const prerenderResumeDataCache = (0, _workunitasyncstorageexternal.getPrerenderResumeDataCache)(workUnitStore);\n        const renderResumeDataCache = (0, _workunitasyncstorageexternal.getRenderResumeDataCache)(workUnitStore);\n        decrypted = (prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.decryptedBoundArgs.get(encrypted)) ?? (renderResumeDataCache == null ? void 0 : renderResumeDataCache.decryptedBoundArgs.get(encrypted));\n        if (!decrypted) {\n            cacheSignal == null ? void 0 : cacheSignal.beginRead();\n            decrypted = await decodeActionBoundArg(actionId, encrypted);\n            cacheSignal == null ? void 0 : cacheSignal.endRead();\n            prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.decryptedBoundArgs.set(encrypted, decrypted);\n        }\n    } else {\n        decrypted = await decodeActionBoundArg(actionId, encrypted);\n    }\n    const { edgeRscModuleMapping, rscModuleMapping } = (0, _encryptionutils.getClientReferenceManifestForRsc)();\n    // Using Flight to deserialize the args from the string.\n    const deserialized = await (0, _clientedge.createFromReadableStream)(new ReadableStream({\n        start (controller) {\n            controller.enqueue(textEncoder.encode(decrypted));\n            if ((workUnitStore == null ? void 0 : workUnitStore.type) === 'prerender') {\n                // Explicitly don't close the stream here (until prerendering is\n                // complete) so that hanging promises are not rejected.\n                if (workUnitStore.renderSignal.aborted) {\n                    controller.close();\n                } else {\n                    workUnitStore.renderSignal.addEventListener('abort', ()=>controller.close(), {\n                        once: true\n                    });\n                }\n            } else {\n                controller.close();\n            }\n        }\n    }), {\n        serverConsumerManifest: {\n            // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n            // to be added to the current execution. Instead, we'll wait for any ClientReference\n            // to be emitted which themselves will handle the preloading.\n            moduleLoading: null,\n            moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n            serverModuleMap: (0, _encryptionutils.getServerModuleMap)()\n        }\n    });\n    return deserialized;\n}\n\n//# sourceMappingURL=encryption.js.map","module.exports = require(\"node:os\");","module.exports = require(\"node:diagnostics_channel\");","import * as Sentry from \"@sentry/nextjs\";\n\n// Track throttled messages to avoid duplicates\ninterface ThrottleCache {\n  [key: string]: {\n    timestamp: number;\n    count: number;\n  };\n}\n\n// Cache for throttling\nconst messageCache: ThrottleCache = {};\nconst MIN_THROTTLE_MS = 5000; // 5 seconds between identical messages\nconst MAX_CACHE_SIZE = 100;\nconst MAX_OBJECT_SIZE = 5000; // Characters limit for stringified objects\n\n/**\n * Safely stringify data, with size limits to prevent performance issues\n */\nconst safeStringify = (data: any): string => {\n  if (data === undefined || data === null) return \"\";\n  if (typeof data === \"string\") return data.substring(0, MAX_OBJECT_SIZE);\n\n  try {\n    const str = JSON.stringify(data);\n    return str.length > MAX_OBJECT_SIZE\n      ? str.substring(0, MAX_OBJECT_SIZE) + \"...[truncated]\"\n      : str;\n  } catch (e) {\n    return \"[Object cannot be serialized]\";\n  }\n};\n\n/**\n * Clean the throttle cache periodically\n */\nconst cleanThrottleCache = (): void => {\n  const now = Date.now();\n  const keys = Object.keys(messageCache);\n\n  if (keys.length > MAX_CACHE_SIZE) {\n    // Remove oldest entries if cache is too large\n    const oldestKeys = keys\n      .map((key) => {\n        // Add safety check for undefined entries\n        if (\n          !messageCache[key] ||\n          typeof messageCache[key].timestamp !== \"number\"\n        ) {\n          return { key, time: 0 };\n        }\n        return { key, time: messageCache[key].timestamp };\n      })\n      .sort((a, b) => a.time - b.time)\n      .slice(0, keys.length - MAX_CACHE_SIZE / 2)\n      .map((item) => item.key);\n\n    oldestKeys.forEach((key) => delete messageCache[key]);\n  }\n\n  // Remove expired entries\n  keys.forEach((key) => {\n    // Add safety check for undefined entries\n    if (\n      messageCache[key] &&\n      typeof messageCache[key].timestamp === \"number\" &&\n      now - messageCache[key].timestamp > MIN_THROTTLE_MS * 10\n    ) {\n      delete messageCache[key];\n    } else if (\n      !messageCache[key] ||\n      typeof messageCache[key].timestamp !== \"number\"\n    ) {\n      // Remove invalid entries that could cause errors\n      delete messageCache[key];\n    }\n  });\n};\n\n// Clean cache every minute\nif (typeof window !== \"undefined\") {\n  setInterval(cleanThrottleCache, 60000);\n}\n\n/**\n * Check if a message is throttled\n * Returns true if the message should be skipped\n */\nconst isThrottled = (cacheKey: string): boolean => {\n  const now = Date.now();\n\n  if (messageCache[cacheKey]) {\n    const { timestamp, count } = messageCache[cacheKey];\n    const elapsed = now - timestamp;\n\n    if (elapsed < MIN_THROTTLE_MS) {\n      // Update count but don't send\n      messageCache[cacheKey].count++;\n      return true;\n    }\n\n    // Update timestamp and count\n    messageCache[cacheKey].timestamp = now;\n    messageCache[cacheKey].count++;\n  } else {\n    // First occurrence\n    messageCache[cacheKey] = { timestamp: now, count: 1 };\n\n    // Clean cache if it gets too large\n    if (Object.keys(messageCache).length > MAX_CACHE_SIZE) {\n      cleanThrottleCache();\n    }\n  }\n\n  return false;\n};\n\n/**\n * Log an error to Sentry with additional context\n */\nexport const captureException = (\n  error: Error | unknown,\n  context?: Record<string, any>\n): void => {\n  // Skip in development for better performance, just log to console\n  if (process.env.NODE_ENV === \"development\") {\n    console.error(error, context);\n    return;\n  }\n\n  // Create a throttle key based on error message\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const throttleKey = `error:${errorMessage.substring(0, 100)}`;\n\n  if (isThrottled(throttleKey)) return;\n\n  // Limit context size to prevent performance issues\n  const safeContext = context\n    ? Object.fromEntries(\n        Object.entries(context).map(([key, value]) => [\n          key,\n          safeStringify(value),\n        ])\n      )\n    : undefined;\n\n  if (error instanceof Error) {\n    Sentry.captureException(error, {\n      extra: safeContext,\n    });\n  } else {\n    Sentry.captureException(new Error(String(error)), {\n      extra: safeContext,\n    });\n  }\n};\n\n/**\n * Log a message to Sentry at the specified level\n */\nexport const captureMessage = (\n  message: string,\n  level: Sentry.SeverityLevel = \"info\",\n  context?: Record<string, any>\n): void => {\n  // Skip low-priority messages in production\n  if (process.env.NODE_ENV === \"production\" && level === \"info\") {\n    return;\n  }\n\n  // Limit message size\n  const safeMessage = message.substring(0, 200);\n\n  // Create throttle key based on message\n  const throttleKey = `${level}:${safeMessage}`;\n\n  if (isThrottled(throttleKey)) return;\n\n  // Limit context size\n  const safeContext = context\n    ? Object.fromEntries(\n        Object.entries(context).map(([key, value]) => [\n          key,\n          safeStringify(value),\n        ])\n      )\n    : undefined;\n\n  Sentry.captureMessage(safeMessage, {\n    level,\n    extra: safeContext,\n  });\n};\n\n/**\n * Set the current user for Sentry tracking\n */\nexport const setUser = (\n  id: string | null,\n  email?: string,\n  username?: string,\n  additionalData?: Record<string, any>\n): void => {\n  if (id) {\n    Sentry.setUser({\n      id,\n      email,\n      username,\n      ...additionalData,\n    });\n  } else {\n    // Clear user data when id is null\n    Sentry.setUser(null);\n  }\n};\n\n/**\n * Add breadcrumb to track user or system actions\n */\nexport const addBreadcrumb = (\n  message: string,\n  category?: string,\n  level: Sentry.SeverityLevel = \"info\",\n  data?: Record<string, any>\n): void => {\n  // Skip breadcrumbs in production for better performance\n  if (process.env.NODE_ENV === \"production\" && level === \"info\") {\n    return;\n  }\n\n  // Limit data size\n  const safeData = data\n    ? Object.fromEntries(\n        Object.entries(data).map(([key, value]) => [key, safeStringify(value)])\n      )\n    : undefined;\n\n  Sentry.addBreadcrumb({\n    message: message.substring(0, 100),\n    category,\n    level,\n    data: safeData,\n  });\n};\n\n/**\n * Set context information for current scope\n */\nexport const setContext = (\n  name: string,\n  context: Record<string, any>\n): void => {\n  // Limit context size\n  const safeContext = Object.fromEntries(\n    Object.entries(context).map(([key, value]) => [key, safeStringify(value)])\n  );\n\n  Sentry.setContext(name, safeContext);\n};\n\n/**\n * Replace console.log in production\n * In development, it will only log to console\n * In production, it will send to Sentry as warning-level message only if important\n */\nexport const log = (message: string, data?: any): void => {\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  if (isDev) {\n    console.log(message, data);\n    return;\n  }\n\n  // In production, only log critical info\n  // Most info logs can be skipped entirely\n  if (\n    message.includes(\"error\") ||\n    message.includes(\"fail\") ||\n    message.includes(\"critical\")\n  ) {\n    captureMessage(`${message}`, \"warning\");\n  }\n};\n\n/**\n * Replace console.error in production\n * Always captures as error in Sentry, only logs to console in development\n */\nexport const logError = (message: string, error?: Error | unknown): void => {\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  if (isDev) {\n    console.error(message, error);\n    return;\n  }\n\n  // Create throttle key for this error\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const throttleKey = `error:${message}:${errorMessage.substring(0, 50)}`;\n\n  if (isThrottled(throttleKey)) return;\n\n  if (error) {\n    captureException(error, { message });\n  } else {\n    captureMessage(message, \"error\");\n  }\n};\n\n/**\n * Replace console.warn in production\n * Captures as warning in Sentry, only logs to console in development\n */\nexport const logWarning = (message: string, data?: any): void => {\n  const isDev = process.env.NODE_ENV === \"development\";\n\n  if (isDev) {\n    console.warn(message, data);\n    return;\n  }\n\n  // Create throttle key for this warning\n  const throttleKey = `warning:${message}`;\n\n  if (isThrottled(throttleKey)) return;\n\n  captureMessage(message, \"warning\");\n};\n\n/**\n * Start performance monitoring span\n * Returns a function to call when the operation is complete\n */\nexport const startSpan = (\n  name: string,\n  op: string,\n  data?: Record<string, any>\n): (() => void) => {\n  // Skip in production environments where we've disabled performance monitoring for speed\n  if (process.env.NODE_ENV === \"production\") {\n    // Return empty function as noop\n    return () => {};\n  }\n\n  try {\n    // Create unique ID for this operation\n    const spanId = `${op}-${name}-${Date.now()}`;\n    const startTime = performance.now();\n\n    // Add breadcrumb for operation start\n    const safeData = data\n      ? Object.fromEntries(\n          Object.entries(data).map(([key, value]) => [\n            key,\n            safeStringify(value),\n          ])\n        )\n      : undefined;\n\n    // Safely add breadcrumb with error handling\n    try {\n      addBreadcrumb(`Started ${op}: ${name}`, \"performance\", \"info\", {\n        ...safeData,\n        spanId,\n      });\n    } catch (e) {\n      // Silently fail breadcrumb to not affect performance\n      console.warn(\"Failed to add breadcrumb:\", e);\n    }\n\n    // Return a function to finish the span\n    return () => {\n      try {\n        const endTime = performance.now();\n        const duration = Math.round(endTime - startTime);\n\n        // Only track operations that took significant time (> 50ms)\n        if (duration > 50) {\n          try {\n            addBreadcrumb(\n              `Finished ${op}: ${name} (${duration}ms)`,\n              \"performance\",\n              duration > 500 ? \"warning\" : \"info\", // Mark slow operations as warnings\n              {\n                ...safeData,\n                duration,\n                spanId,\n              }\n            );\n\n            // For very slow operations (>1s), send a performance issue\n            if (duration > 1000) {\n              captureMessage(\n                `Slow operation: ${op} - ${name} took ${duration}ms`,\n                \"warning\",\n                {\n                  performance: true,\n                  duration,\n                  operation: op,\n                  ...safeData,\n                }\n              );\n            }\n          } catch (e) {\n            // Silently fail to not affect performance\n            console.warn(\"Failed to record performance data:\", e);\n          }\n        }\n      } catch (e) {\n        // Silently fail to not affect performance\n        console.warn(\"Failed to finish performance span:\", e);\n      }\n    };\n  } catch (e) {\n    // Return a no-op function if anything fails\n    console.warn(\"Failed to start performance tracking:\", e);\n    return () => {};\n  }\n};\n\n/**\n * Set extra data on the current scope\n */\nexport const setExtra = (key: string, value: any): void => {\n  Sentry.setExtra(key, safeStringify(value));\n};\n","module.exports = require(\"crypto\");","module.exports = require(\"https\");","module.exports = require(\"tls\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"node:crypto\");","module.exports = require(\"buffer\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"http\");","/* eslint-disable import/no-extraneous-dependencies */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"registerServerReference\", {\n    enumerable: true,\n    get: function() {\n        return _serveredge.registerServerReference;\n    }\n});\nconst _serveredge = require(\"react-server-dom-webpack/server.edge\");\n\n//# sourceMappingURL=server-reference.js.map","module.exports = require(\"tty\");","\"use server\";\n\nimport { createClient } from \"$/supabase/server\";\nimport { generateEthereumWallet } from \"@/utils\";\nimport { Client } from \"$/supabase/client\";\nimport { ExtendedUser } from \"$/types/data.types\";\nimport { logError } from \"@/utils/sentryUtils\";\n\nexport const getUser = async (\n  client?: Client\n): Promise<Partial<ExtendedUser> | null> => {\n  const supabase = await createClient();\n\n  const authClient = client ?? supabase;\n  const { data: userData, error } = await authClient.auth.getUser();\n\n  if (error) {\n    logError(\"Error fetching auth user\", error);\n    return null;\n  }\n\n  //get data from profile data\n  const { data: profileData, error: profileError } = await supabase\n    .from(\"profiles\")\n    .select(\"*\")\n    .eq(\"id\", userData?.user?.id);\n\n  if (profileError) {\n    logError(\"Error fetching user profile data\", profileError);\n    return null;\n  }\n\n  //check if user has a wallet\n  if (!profileData[0].wallet) {\n    const wallet = generateEthereumWallet();\n\n    const { error: walletError } = await supabase\n      .from(\"profiles\")\n      .update({ wallet }) // Set new wallet\n      .eq(\"id\", profileData[0].id) // Where the user_id matches\n      .single(); // Ensures only one row is returned\n\n    if (walletError) {\n      logError(\"Error updating user wallet\", walletError);\n      return null;\n    }\n  }\n\n  const user = {\n    ...userData,\n    wallet: profileData[0].wallet as WalletObject | undefined,\n    bio: profileData[0].bio as string,\n    location: profileData[0].location as string,\n    creditBalance: profileData[0].credit_balance as number,\n    full_name: profileData[0].full_name as string,\n    username: profileData[0].display_name || profileData[0].full_name,\n    avatar_url: profileData[0].avatar_url as string,\n  };\n  return user;\n};\n","module.exports = require(\"async_hooks\");","\nexport { getUser as \"7fbe796e2ed096f78d3b020da10b4dbad05ca067aa\" } from \"/Users/a0000/projects/unreal/src/queries/user.ts\"\n","module.exports = require(\"node:inspector\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 87558;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 91093;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"net\");","module.exports = require(\"events\");"],"names":["generateEthereumWallet","wallet","ethers","createRandom","address","privateKey","publicKey","getRange","page","limit","from","createThirdwebClient","clientId","process","POST","req","private_SRK","env","SUPABASE_SERVICE_ROLE_KEY","secretSupabaseClient","createClient","supabaseUrl","requestData","json","user","getUser","creditBalance","error","rpc","queue_name","msg","Error","NextResponse","status","console","serverComponentModule.GET","serverComponentModule.POST","serverComponentModule.PUT","serverComponentModule.PATCH","serverComponentModule.DELETE","serverComponentModule.HEAD","serverComponentModule.OPTIONS","cookieStore","cookies","createServerClient","getAll","setAll","cookiesToSet","forEach","name","value","options","set","auth","autoRefreshToken","persistSession","detectSessionInUrl","__next_loaded_action_key","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","normalizeAppPath","serverActionsManifestSingleton","InvariantError","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping","route","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","messageCache","safeStringify","substring","MAX_OBJECT_SIZE","str","JSON","stringify","e","cleanThrottleCache","now","Date","keys","MAX_CACHE_SIZE","map","timestamp","time","sort","a","b","slice","item","MIN_THROTTLE_MS","isThrottled","cacheKey","count","elapsed","captureException","context","errorMessage","message","throttleKey","safeContext","fromEntries","entries","Sentry","extra","level","safeMessage","logError","captureMessage","op","ensureServerEntryExports","actions","action","client","supabase","authClient","userData","profileData","profileError","select","eq","id","walletError","update","single","bio","location","credit_balance","full_name","username","display_name","avatar_url"],"sourceRoot":""}